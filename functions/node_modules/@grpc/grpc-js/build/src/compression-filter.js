"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressionFilterFactory = exports.CompressionFilter = void 0;
const zlib = require("zlib");
const compression_algorithms_1 = require("./compression-algorithms");
const constants_1 = require("./constants");
const filter_1 = require("./filter");
const logging = require("./logging");
const isCompressionAlgorithmKey = (key) => {
    return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';
};
class CompressionHandler {
    /**
     * @param message Raw uncompressed message bytes
     * @param compress Indicates whether the message should be compressed
     * @return Framed message, compressed if applicable
     */
    async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
            messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    /**
     * @param data Framed message, possibly compressed
     * @return Uncompressed message
     */
    async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
            messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
    }
}
class IdentityHandler extends CompressionHandler {
    async compressMessage(message) {
        return message;
    }
    async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        /* With "identity" compression, messages should always be marked as
         * uncompressed */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
    }
    decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
}
class DeflateHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.deflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            let totalLength = 0;
            const messageParts = [];
            const decompresser = zlib.createInflate();
            decompresser.on('data', (chunk) => {
                messageParts.push(chunk);
                totalLength += chunk.byteLength;
                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
                    decompresser.destroy();
                    reject({
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
                    });
                }
            });
            decompresser.on('end', () => {
                resolve(Buffer.concat(messageParts));
            });
            decompresser.write(message);
            decompresser.end();
        });
    }
}
class GzipHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.gzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            let totalLength = 0;
            const messageParts = [];
            const decompresser = zlib.createGunzip();
            decompresser.on('data', (chunk) => {
                messageParts.push(chunk);
                totalLength += chunk.byteLength;
                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
                    decompresser.destroy();
                    reject({
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
                    });
                }
            });
            decompresser.on('end', () => {
                resolve(Buffer.concat(messageParts));
            });
            decompresser.write(message);
            decompresser.end();
        });
    }
}
class UnknownHandler extends CompressionHandler {
    constructor(compressionName) {
        super();
        this.compressionName = compressionName;
    }
    compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
        // This should be unreachable
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
}
function getCompressionHandler(compressionName, maxReceiveMessageSize) {
    switch (compressionName) {
        case 'identity':
            return new IdentityHandler();
        case 'deflate':
            return new DeflateHandler(maxReceiveMessageSize);
        case 'gzip':
            return new GzipHandler(maxReceiveMessageSize);
        default:
            return new UnknownHandler(compressionName);
    }
}
class CompressionFilter extends filter_1.BaseFilter {
    constructor(channelOptions, sharedFilterConfig) {
        var _a, _b;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if (compressionAlgorithmKey !== undefined) {
            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
                const serverSupportedEncodings = (_b = sharedFilterConfig.serverSupportedEncodingHeader) === null || _b === void 0 ? void 0 : _b.split(',');
                /**
                 * There are two possible situations here:
                 * 1) We don't have any info yet from the server about what compression it supports
                 *    In that case we should just use what the client tells us to use
                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
                 *    In that case we only want to use the encoding chosen by the client if the server supports it
                 */
ame8 2 1>5SPublisherCacheFolderIDX_PublisherCacheFolder_FolderName8 2;5MPublisherCacheFolderIDX_PublisherCacheFolder__WorkId0 0YSkSharedPackageContainerPackageFamilyIDX_SharedPackageContainerPackageFamily__WorkId0 0       Å*+¯∞jYg¢*@∏≤èW   V ƒ¶xMÏ¿Ñ9ÍüVÕ_¢yP
Ÿ
Æ
}
V
	π	à	Q	ÎæÉ?„Øz;€òK≠t0„l¢uI≈öp3»V% Í ¥                                              4y'GPackageFamilyIDX_PackageFamily_PublisherId136 129x3KPackageFamilyPolicyIDX_PackageFamilyPolicy__WorkId0 0/w!EActivationIDX_Activation_ActivationKey269 1pv!Å)3ActivationIDX_Activation_Flags_Executable_Entrypoint_RuntimeType_StartPage_ResourceGroup269 45 45 2 1 1 1 18u)MBundleResourceIDX_BundleResource_BundlePackage6506 3/t)ABundleResourceIDX_BundleResource__WorkId0 0;s#[HostRuntimeIDX_HostRuntime_PackageExtension_HostId2 1 1(r#9HostRuntimeIDX_HostRuntime_HostId2 1)q#;HostRuntimeIDX_HostRuntime__WorkId0 0Jp3iApplicationIdentityIDX_ApplicationIdentity_ApplicationUserModelId224 16o%KAppExtensionIDX_AppExtension_Extension_Name275 1 1*n%7AppExtensionIDX_AppExtension_Name275 3+m%=AppExtensionIDX_AppExtension__WorkId0 0hl1Å'WowDependencyGraphIDX_WowDependencyGraph_User_DependentPackage_SupplierPackage__WorkId120 120 3 1 1^k1Å'WowDependencyGraphIDX_WowDependencyGraph_User_DependentPackage_Index__WorkId120 120 3 1 1uj1Å/'WowDependencyGraphIDX_WowDependencyGraph_User_DependentPackage_DependencyType__WowDependencyGraphID120 120 3 3 1Ki1c!WowDependencyGraphIDX_WowDependencyGraph_User_SupplierPackage120 120 11Bh1YWowDependencyGraphIDX_WowDependencyGraph_SupplierPackage120 117g1IWowDependencyGraphIDX_WowDependencyGraph__WorkId0 0Rf;mPackageExternalLocationIDX_PackageExternalLocation_User_Package__WorkId5 3 1 1He;]PackageExternalLocationIDX_PackageExternalLocation_User__WorkId5 3 3Kd;cPackageExternalLocationIDX_PackageExternalLocation_Package__WorkId5 1 1Ac;SPackageExternalLocationIDX_PackageExternalLocation__WorkId0 09bQ#ResourceIDX_Resource_Package_Index__WorkId3769 25 1 1#a5ResourceIDX_Resource__WorkId0 0=`-SAppExtensionHostIDX_AppExtensionHost_Extension_Name14 1 13_-EAppExtensionHostIDX_AppExtensionHost__WorkId0 02^!IAppServiceIDX_AppService_Extension_Index36 1 11]!GAppServiceIDX_AppService_Name_Extension36 1 1'\!9AppServiceIDX_AppService__WorkId0 0B[#aPrimaryTileIDX_PrimaryTile_Application_TileId__WorkId221 1 1 19Z#SPrimaryTileIDX_PrimaryTile_Application__WorkId221 1 1+Y#;PrimaryTileIDX_PrimaryTile_Package221 2)X#;PrimaryTileIDX_PrimaryTile__WorkId0 09W#SPrimaryTileIDX_PrimaryTile_Package_Application221 2 15V)IMrtApplicationIDX_MrtApplication_Application221 1/U)AMrtApplicationIDX_MrtApplication__WorkId0 0TT?kApplicationContentUriRuleIDX_ApplicationContentUriRule_Application_Index145 12 1ES?WApplicationContentUriRuleIDX_ApplicationContentUriRule__WorkId0 0%R7SRJournalIDX_SRJournal__WorkId0 0/Q#CDefaultTileIDX_DefaultTile_Application221 1)P#;DefaultTileIDX_DefaultTile__WorkId0 09O!UDependencyIDX_Dependency_DependentPackage_Name130 3 1:N!WDependencyIDX_Dependency_DependentPackage_Index130 3 1'M!3DependencyIDX_Dependency_Name130 10'L!9DependencyIDX_Dependency__WorkId0 0bK+Å'DependencyGraphIDX_DependencyGraph_User_DependentPackage_SupplierPackage__WorkId210 105 4 1 1WJ+{'DependencyGraphIDX_DependencyGraph_User_DependentPackage_Index__WorkId210 105 4 1 1lI+Å#'DependencyGraphIDX_DependencyGraph_User_DependentPackage_DependencyType__DependencyGraphID210 105 4 3 1DH+]DependencyGraphIDX_DependencyGraph_User_SupplierPackage210 105 3FG+eDependencyGraphIDX_DependencyGraph_DependentPackage__WorkId21FÅG3[FileTypeAssociationIDX_FileTypeAssociation_Extension_Index254 10 1HÅF3aFileTypeAssociationIDX_FileTypeAssociation_FileType_Extension254 2 1LÅE3gFileTypeAssociationIDX_FileTypeAssociation_ContentType_Extension254 64 9HÅD3]Fi