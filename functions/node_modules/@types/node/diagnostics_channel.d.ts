/**
 * The `node:diagnostics_channel` module provides an API to create named channels
 * to report arbitrary message data for diagnostics purposes.
 *
 * It can be accessed using:
 *
 * ```js
 * import diagnostics_channel from 'node:diagnostics_channel';
 * ```
 *
 * It is intended that a module writer wanting to report diagnostics messages
 * will create one or many top-level channels to report messages through.
 * Channels may also be acquired at runtime but it is not encouraged
 * due to the additional overhead of doing so. Channels may be exported for
 * convenience, but as long as the name is known it can be acquired anywhere.
 *
 * If you intend for your module to produce diagnostics data for others to
 * consume it is recommended that you include documentation of what named
 * channels are used along with the shape of the message data. Channel names
 * should generally include the module name to avoid collisions with data from
 * other modules.
 * @since v15.1.0, v14.17.0
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/diagnostics_channel.js)
 */
declare module "diagnostics_channel" {
    import { AsyncLocalStorage } from "node:async_hooks";
    /**
     * Check if there are active subscribers to the named channel. This is helpful if
     * the message you want to send might be expensive to prepare.
     *
     * This API is optional but helpful when trying to publish messages from very
     * performance-sensitive code.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * if (diagnostics_channel.hasSubscribers('my-channel')) {
     *   // There are subscribers, prepare and publish message
     * }
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return If there are active subscribers
     */
    function hasSubscribers(name: string | symbol): boolean;
    /**
     * This is the primary entry-point for anyone wanting to publish to a named
     * channel. It produces a channel object which is optimized to reduce overhead at
     * publish time as much as possible.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channel = diagnostics_channel.channel('my-channel');
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return The named channel object
     */
    function channel(name: string | symbol): Channel;
    type ChannelListener = (message: unknown, name: string | symbol) => void;
    /**
     * Register a message handler to subscribe to this channel. This message handler
     * will be run synchronously whenever a message is published to the channel. Any
     * errors thrown in the message handler will trigger an `'uncaughtException'`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * diagnostics_channel.subscribe('my-channel', (message, name) => {
     *   // Received data
     * });
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The handler to receive channel messages
     */
    function subscribe(name: string | symbol, onMessage: ChannelListener): void;
    /**
     * Remove a message handler previously registered to this channel with {@link subscribe}.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * function onMessage(message, name) {
     *   // Received data
     * }
     *
     * diagnostics_channel.subscribe('my-channel', onMessage);
     *
     * diagnostics_channel.unsubscribe('my-channel', onMessage);
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The previous subscribed handler to remove
     * @return `true` if the handler was found, `false` otherwise.
     */
    function unsubscribe(name: string | symbol, onMessage: ChannelListener): boolean;
    /**
     * Creates a `TracingChannel` wrapper for the given `TracingChannel Channels`. If a name is given, the corresponding tracing
     * channels will be created in the form of `tracing:${name}:${eventType}` where `eventType` corresponds to the types of `TracingChannel Channels`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channelsByName = diagnostics_channel.tracingChannel('my-channel');
     *
     * // or...
     *
     * const channelsByCollection = diagnostics_channel.tracingChannel({
     *   start: diagnostics_channel.channel('tracing:my-channel:start'),
     *   end: diagnostics_channel.channel('tracing:my-channel:end'),
     *   asyncStart: diagnostics_channel.channel('tracing:my-channel:asyncStart'),
     *   asyncEnd: diagnostics_channel.channel('tracing:my-channel:asyncEnd'),
     *   error: diagnostics_channel.channel('tracing:my-channel:error'),
     * });
     * ```
     * @since v19.9.0
     * @experimental
     * @param nameOrChannels Channel name or object containing all the `TracingChannel Channels`
     * @return Collection of channels to trace with
     */
    function tracingChannel<
        StoreType = unknown,
        ContextType extends object = StoreType extends object ? StoreType : object,
    >(
        nameOrChannels: string | TracingChannelCollection<StoreType, ContextType>,
    ): TracingChannel<StoreType, ContextType>;
    /**
     * The class `Channel` represents an individual named channel within the data
     * pipeline. It is used to track subscribers and to publish messages when there
     * are subscribers present. It exists as a separate object to avoid channel
     * lookups at publish time, enabling very fast publish speeds and allowing
     * for heavy use while incurring very minimal cost. Channels are created with {@link channel}, constructing a channel directly
     * with `new Channel(name)` is not supported.
     * @since v15.1.0, v14.17.0
     */
    class Channel<StoreType = unknown, ContextType = StoreType> {
        readonly name: string | symbol;
        /**
         * Check if there are active subscribers to this channel. This is helpful if
         * the message you want to send might be expensive to prepare.
         *
         * This API is optional but helpful when trying to publish messages from very
         * performance-sensitive code.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * if (channel.hasSubscribers) {
         *   // There are subscribers, prepare and publish message
         * }
         * ```
         * @since v15.1.0, v14.17.0
         */
        readonly hasSubscribers: boolean;
        private constructor(name: string | symbol);
        /**
         * Publish a message to any subscribers to the channel. This will trigger
         * message handlers synchronously so they will execute within the same context.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.publish({
         *   some: 'message',
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @param message The message to send to the channel subscribers
         */
        publish(message: unknown): void;
        /**
         * Register a message handler to subscribe to this channel. This message handler
         * will be run synchronously whenever a message is published to the channel. Any
         * errors thrown in the message handler will trigger an `'uncaughtException'`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.subscribe((message, name) => {
         *   // Received data
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link subscribe(name, onMessage)}
         * @param onMessage The handler to receive channel messages
         */
        subscribe(onMessage: ChannelListener): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.subscribe(onMessage)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * function onMessage(message, name) {
         *   // Received data
         * }
         *
         * channel.subscribe(onMessage);
         *
         * channel.unsubscribe(onMessage);
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link unsubscribe(name, onMessage)}
         * @param onMessage The previous subscribed handler to remove
         * @return `true` if the handler was found, `false` otherwise.
         */
        unsubscribe(onMessage: ChannelListener): void;
        /**
         * When `channel.runStores(context, ...)` is called, the given context data
         * will be applied to any store bound to the channel. If the store has already been
         * bound the previous `transform` function will be replaced with the new one.
         * The `transform` function may be omitted to set the given context data as the
         * context directly.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (data) => {
         *   return { data };
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to which to bind the context data
         * @param transform Transform context data before setting the store context
         */
        bindStore(store: AsyncLocalStorage<StoreType>, transform?: (context: ContextType) => StoreType): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.bindStore(store)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store);
         * channel.unbindStore(store);
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to unbind from the channel.
         * @return `true` if the store was found, `false` otherwise.
         */
        unbindStore(store: AsyncLocalStorage<StoreType>): boolean;
        /**
         * Applies the given data to any AsyncLocalStorage instances bound to the channel
         * for the duration of the given function, then publishes to the channel within
         * the scope of that data is applied to the stores.
         *
         * If a transform function was given to `channel.bindStore(store)` it will be
         * applied to transform the message data before it becomes the context value for
         * the store. The prior storage context is accessible from within the transform
         * function in cases where context linking is required.
         *
         * The context applied to the store should be accessible in any async code which
         * continues from execution which began during the given function, however
         * there are some situations in which `context loss` may occur.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (message) => {
         *  INDX( 	 æê2÷           (   à  Ë      ¨        €~ €        _5   ? ` P     1   $ ⁄©ìx¿Ï€	g…Ï€	g…Ï€	g…Ï€       ’              . w p n . j s ›    4 x b     1   $  óx¿Ï€√¸sx¿Ï€√¸sx¿Ï€]7˙»Ï€       Í              A l i y u n C o n f i g . i n i    / 1   < p ^     1   $ |ª•Ï€ `†M˘ÿñ•‚6¿Ï€ÉC4˙»Ï€ ¿     êø             A l i y u n W r a p . d l l   1   / x d     1   $ ∞%ª•Ï€ ç7°M˘ÿÈ‰6¿Ï€d#õx¿Ï€ ‡     ê—             A l i y u n W r a p E x e . e x e   ¨ 1   < p Z     1   $ |ª•Ï€ `†M˘ÿñ•‚6¿Ï€ÉC4˙»Ï€ ¿     êø             A L I Y U N ~ 1 . D L L       1   / p Z     1   $ ∞%ª•Ï€ ç7°M˘ÿÈ‰6¿Ï€d#õx¿Ï€ ‡     ê—             A L I Y U N ~ 1 . E X E       ›    4 p Z     1   $  óx¿Ï€√¸sx¿Ï€√¸sx¿Ï€]7˙»Ï€       Í              A L I Y U N ~ 1 . I N I o r e A2   I p Z     1   $ Õ—5ª•Ï€ æó'»⁄ÿÛñ7¿Ï€¨‡Óx¿Ï€ P      O              A P 0 4 7 9 ~ 1 . D L L o r e B2   6 p Z     1   $ 7ª•Ï€ æó'»⁄ÿÔ•7¿Ï€~hÒx¿Ï€ P    ¨ K              A P 2 3 C 9 ~ 1 . D L L o r e É1   ) p Z     1   $ ã"ª•Ï€ ëf&»⁄ÿƒµÙ6¿Ï€P¶πx¿Ï€ P      I              A P 2 5 B 1 ~ 1 . D L L o r e k1   & p Z     1   $ ˆ7ª•Ï€ æó'»⁄ÿÍ%6¿Ï€%±x¿Ï€ P      G              A P 2 6 B 7 ~ 1 . D L L o r e  2   5 p Z     1   $ |F0ª•Ï€ æó'»⁄ÿ}G7¿Ï€”∞€x¿Ï€        
              A P 3 A 3 D ~ 1 . D L L o r e p1     p Z     1   $ M
 ª•Ï€ æó'»⁄ÿÌgÒ6¿Ï€ê?≥x¿Ï€ P      I              A P 4 0 C 7 ~ 1 . D L L o r e V1   7 p Z   ¨ 1   $ íFª•Ï€ æó'»⁄ÿÔ6¿Ï€jÙÆx¿Ï€ P      G              A P 4 F 6 3 ~ 1 . D L L o r e ¢1    p Z     1   $ ‡Q$ª•Ï€ ëf&»⁄ÿ¢øˆ6¿Ï€Üæx¿Ï€ P      K              A P 5 0 7 A ~ 1 . D L L o r e Ÿ1    p Z     1   $ ”''ª•Ï€ æó'»⁄ÿÈ◊˘6¿Ï€Ú≈x¿Ï€ P      E              A P 5 5 7 4 ~ 1 . D L L o r e +2    p Z     1   $ 
’1ª•Ï€ æó'»⁄ÿFì7¿Ï€˜Âx¿Ï€ P      K              A P 5 C 7 6 ~ 1 . D L L o r e Ô2    p Z     1   $ …áAª•Ï€ æó'»⁄ÿ™|7¿Ï€˘»"y¿Ï€ `      Q            ¨ A P 5 E 4 C ~ 1 . D L L o r e ~1   ' p Z     1   $ Û !ª•Ï€ æó'»⁄ÿ–›Û6¿Ï€HÇ∑x¿Ï€ `      Q              A P 6 2 2 1 ~ 1 . D L L o r e               1   $ ∑*ª•Ï€ æó'»⁄ÿçØ†•Ï€Ô-*ª•Ï€ P      O              A P 7 6 7 8 ~ 1 . D L L o r e 2   ) p Z     1   $ ¬…-ª•Ï€ æó'»⁄ÿ7A±†•Ï€UÒ-ª•Ï€ P      I              A P 7 9 0 2 ~ 1 . D L L o r e Ñ1   p p Z     1   $ l|#ª•Ï€ æó'»⁄ÿá¥®†•Ï€l|#ª•Ï€ P      G              A P 8 5 2 6 ~ 1 . D L L o r e 71   L p Z     1   $ Zèª•Ï¨  æó'»⁄ÿ˝‘°†•Ï€ï∂ª•Ï€ `      U              A P 8 7 F 4 ~ 1 . D L L o r e =2    p Z     1   $ 1H4ª•Ï€ ëf&»⁄ÿ¡=µ†•Ï€ko4ª•Ï€ P      I              A P C 0 0 F ~ 1 . D L L o r e A1   ©p Z     1   $ [hª•Ï€ æó'»⁄ÿí£†•Ï€êèª•Ï€ P      G              A P C 7 B 0 ~ 1 . D L L o r e s1   & p Z     1   $ Ω!ª•Ï€ ëf&»⁄ÿT›•†•Ï€Ω!ª•Ï€ P      K              A P D 0 F 3 ~ 1 . D L L o r e €1   ! p Z     1   $ Ï(ª•Ï€ æó'»⁄ÿ®‰¨†•Ï€Ù,(ª•Ï€ P      E              A P D C 3 0 ¨ 1 . D L L o r e ?1    p Z     1   $ ãzª•Ï€ æó'»⁄ÿ$b¢†•Ï€∏°ª•Ï€ P      G              A P D E A 0 ~ 1 . D L L o r e ¿1   ( p Z     1   $ -%ª•Ï€ æó'»⁄ÿF™†•Ï€•>%ª•Ï€ P      O              A P E F 2 A ~ 1 . D L L o r e ˝1   Ã p Z     1   $ {±+ª•Ï€ æó'»⁄ÿA≥Ø†•Ï€ºÿ+ª•Ï€ P      I              A P F 1 0 C ~ 1 . D L L o r e 2   S p Z     1   $ xµ.ª•Ï€ æó'»⁄ÿÆ€±†•Ï€ÑÌ.ª•Ï€ P      G              A P F 2 D B ~ 1 . D L L o r e 2   
 p Z     1   $ aø,ª•Ï€ æó'»⁄ÿàé∞†•Ï¨ ·Û,ª•Ï€ P      K              A P F A D 9 ~ 1 . D L L o r e :2     p Z     1   $ î*3ª•Ï€ æó'»⁄ÿ¶~¥†•Ï€]]3ª•Ï€ `      W              A P F D 9 C ~ 1 . D L L o r e 1   B ò Ü     1   $ íÈª•Ï€ æó'»⁄ÿ[Áû†•Ï€”ª•Ï€ P      I              "a p i - m s - w i n - c o r e - c o n s o l e - l 1 - 1 - 0 . d l l   1   
 ò à     1   $ ‘Œª•Ï€ æó'»⁄ÿwòü†•Ï€ˆª•Ï€ P      G              #a p i - m s - w i n - c o r e - d a t e t i m e - l 1 - 1 - 0 . d l l                             ¨ INDX( 	 ≥ [–          (   à  Ë       0   i e - €~         01   ( ® í     1   $ ‡∏ª•Ï€ æó'»⁄ÿo>Í6¿Ï€
§x¿Ï€ P      G              (a p i - m s - w i n - c o r e - e r r o r h a n d l i n g - l 1 - 1 - 0 . d l l ª•Ï€71   L ê Ä     1   $ Zèª•Ï€ æó'»⁄ÿßDÎ6¿Ï€àˆ•x¿Ï€ `      U              a p i - m s - w i n - c o r e - f i l e - l 1 - 1 - 0 . d l l ?1    ê Ä     1   $ ãzª•Ï€ æó'»⁄ÿÉÏ6¿Ï€≤®x¿Ï€ P      G              a p i - m s - w i n - c o r e - f i l e - l 1 - 2 -  . d l l A1   ©ê Ä     1   $ [hª•Ï€ æó'»⁄ÿÀÌ6¿Ï€[Î´x¿Ï€ P      G              a p i - m s - w i n - c o r e - f i l e - l 2 - 1 - 0 . d l l V1   7 ò Ñ     1   $ íFª•Ï€ æó'»⁄ÿÔ6¿Ï€jÙÆx¿Ï€ P      G              !a p i - m s - w i n - c o r e - h a n d l e - l 1 - 1 - 0 . d l l »⁄ÿk1   & ê Ä     1   $ ˆ7ª•Ï€ æó'»⁄ÿÍ%6¿Ï€%±x¿Ï€ P      G              a p i - m s - w i n - c o r e - h e a p - l 1 - 1 - 0 . d l l p1     † é     1   $ M
 ª•Ï€ æó'»⁄ÿÌgÒ6¿Ï€ê?≥x¿Ï€ P     I              &a p i - m s - w i n - c o r e - i n t e r l o c k e d - l 1 - 1 - 0 . d l l €s1   & ® í     1   $ Ω!ª•Ï€ ëf&»⁄ÿ´åÚ6¿Ï€¥µx¿Ï€ P      K              (a p i - m s - w i n - c o r e - l i b r a r y l o a d e r - l 1 - 1 - 0 . d l l ª•Ï€~1   ' † ê     1   $ Û !ª•Ï€ æó'»⁄ÿ–›Û6¿Ï€HÇ∑x¿Ï€ `      Q              'a p i - m s - w i n - c o r e - l o c a l i z a t i o n - l 1 - 2 - 0 . d l l É1   ) ò Ñ     1   $ ã"ª•Ï€ ëf&»⁄ÿƒµÙ6¿Ï€P¶πx¿Ï€ P      I              !a p  - m s - w i n - c o r e - m e m o r y - l 1 - 1 - 0 . d l l »⁄ÿÑ1   p † ä     1   $ l|#ª•Ï€ æó'»⁄ÿ∑®ı6¿Ï€ã˙ªx¿Ï€ P      G              $a p i - m s - w i n - c o r e - n a m e d p i p e - l 1 - 1 - 0 . d l l ü†•Ï€¢1    ∞ ú     1   $ ‡Q$ª•Ï€ ëf&»⁄ÿ¢øˆ6¿Ï€Üæx¿Ï€ P      K              -a p i - m s - w i n - c o r e - p r o c e s s e n v i r o n m e n t - l 1 - 1 - 0 . d l l                   1   $ -%ª•Ï€ æó'»⁄ÿF™†•Ï€•>%ª•Ï€ P      O              )a p i - m s - w i n - c o r  - p r o c e s s t h r e a d s - l 1 - 1 - 0 . d l l •Ï€À1    ® î     1   $ &ª•Ï€ æó'»⁄ÿÁ¯™†•Ï€)2&ª•Ï€ P      I              )a p i - m s - w i n - c o r e - p r o c e s s t h r e a d s - l 1 - 1 - 1 . d l l •Ï€Ÿ1    ò Ü     1   $ ”''ª•Ï€ æó'»⁄ÿv€´†•Ï€CO'ª•Ï€ P      E              "a p i - m s - w i n - c o r e - p r o f i l e - l 1 - 1 - 0 . d l l ÿ€1   ! † å     1   $ Ï(ª•Ï€ æó'»⁄ÿ®‰¨†•Ï€Ù,(ª•Ï€ P      E              %a p i - m s - w i n - c o r e - r t l s u p p o r t  l 1 - 1 - 0 . d l l •Ï€1    ò Ñ     1   $ K)ª•Ï€ æó'»⁄ÿÏ÷≠†•Ï€ªB)ª•Ï€ P      G              !a p i - m s - w i n - c o r e - s t r i n g - l 1 - 1 - 0 . d l l »⁄ÿÛ1   : ò Ç     1   $ ∑*ª•Ï€ æó'»⁄ÿçØ†•Ï€Ô-*ª•Ï€ P      O               a p i - m s - w i n - c o r e - s y n c h - l 1 - 1 - 0 . d l l ó'»⁄ÿ˝1   Ã ò Ç     1   $ {±+ª•Ï€ æó'»⁄ÿA≥Ø†•Ï€ºÿ+ª•Ï€ P      I               a p i - m s - w i n - c o r e - s y n c h - l 1 - 2 - 0 . d l l ó'»⁄ÿ2   
 ò Ü     1   $ aø,ª•Ï  æó'»⁄ÿàé∞†•Ï€·Û,ª•Ï€ P      K              "a p i - m s - w i n - c o r e - s y s i n f o - l 1 - 1 - 0 . d l l ÿ2   ) ò à     1   $ ¬…-ª•Ï€ æó'»⁄ÿ7A±†•Ï€UÒ-ª•Ï€ P      I              #a p i - m s - w i n - c o r e - t i m e z o n e - l 1 - 1 - 0 . d l l 2   S ê Ä     1   $ xµ.ª•Ï€ æó'»⁄ÿÆ€±†•Ï€ÑÌ.ª•Ï€ P      G              a p i - m s - w i n - c o r e - u t i l - l 1 - 1 - 0 . d l l 1   B p Z     1   $ íÈª•Ï€ æó'»⁄ÿ[Áû†•Ï€”ª•Ï€ P      I              A P I - M S  1 . D L L       1   
 p Z     1   $ ‘Œª•Ï€ æó'»⁄ÿwòü†•Ï€ˆª•Ï€ P      G              A P I - M S ~ 2 . D L L       *1   – p Z     1   $ à¶ª•Ï€ æó'»⁄ÿc`††•Ï€πÕª•Ï€ P      G              A P I - M S ~ 3 . D L L       01   ( p Z     1   $ ‡∏ª•Ï€ æó'»⁄ÿj°†•Ï€‡∏ª•Ï€ P      G              A P I - M S ~ 4 . D L L       1   7 h R     1   $ IÃª•Ï€ æó'»⁄ÿ9Çó†•Ï€jÛª•Ï€8       7               W P N ~ 1 . J S                                                            INDX( 	 µ \–          (      Ë       p $ I d €-           À1    ® î     1   $ &ª•Ï€ æó'»⁄ÿŒÏ¯6¿Ï€™l√x¿Ï€ P      I              )a p i - m s - w i n - c o r e - p r o c e s s t h r e a d s - l 1 - 1 - 1 . d l l •Ï€Ÿ1    ò Ü     1   $ ”''ª•Ï€ æó'»⁄ÿÈ◊˘6¿Ï€Ú≈x¿Ï€ P      E              "a p i - m s - w i n - c o r e - p r o f i l e - l 1 - 1 - 0 . d l l ÿ€1   ! † å     1   $ Ï(ª•Ï€ æó'»⁄ÿ|À˙6¿Ï€∞Y…x¿Ï€ P      E              %a p i - m s - w i n - c o r e - r t l s u p  o r t - l 1 - 1 - 0 . d l l •Ï€1    ò Ñ     1   $ K)ª•Ï€ æó'»⁄ÿ%˜˚6¿Ï€_yÀx¿Ï€ P      G              !a p i - m s - w i n - c o r e - s t r i n g - l 1 - 1 - 0 . d l l »⁄ÿÛ1   : ò Ç     1   $ ∑*ª•Ï€ æó'»⁄ÿÏŒ¸6¿Ï€¿≈Õx¿Ï€ P      O               a p i - m s - w i n - c o r e - s y n c h - l 1 - 1 - 0 . d l l ó'»⁄ÿ˝1   Ã ò Ç     1   $ {±+ª•Ï€ æó'»⁄ÿÀ˛6¿Ï€3–x¿Ï€ P      I               a p i - m s - w i n - c o r e - s y n c h - l 1 - 2 - 0 . d l l ó'»⁄ÿ2   
 ò Ü     1    aø,ª•Ï€ æó'»⁄ÿ%,ˇ6¿Ï€m¶“x¿Ï€ P      K              "a p i - m s - w i n - c o r e - s y s i n f o - l 1 - 1 - 0 . d l l ÿ2   ) ò à     1   $ ¬…-ª•Ï€ æó'»⁄ÿì> 7¿Ï€X"’x¿Ï€ P      I              #a p i - m s - w i n - c o r e - t i m e z o n e - l 1 - 1 - 0 . d l l 2   S ê Ä     1   $ xµ.ª•Ï€ æó'»⁄ÿôg7¿Ï€ºm◊x¿Ï€ P      G              a p i - m s - w i n - c o r e - u t i l - l 1 - 1 - 0 . d l l  2   5 ò Ñ     1   $ |F0ª•Ï€ æó'»⁄ÿ}G7¿Ï€”∞€x¿Ï€        
              !A P  - M S - W i n - c o r e - x s t a t e - l 2 - 1 - 0 . d l l »⁄ÿ+2    ê Ä     1   $ 
’1ª•Ï€ æó'»⁄ÿFì7¿Ï€˜Âx¿Ï€ P      K              a p i - m s - w i n - c r t - c o n i o - l 1 - 1 - 0 . d l l :2     ò Ñ     1   $ î*3ª•Ï€ æó'»⁄ÿg~7¿Ï€≈ùÈx¿Ï€ `      W              !a p i - m s - w i n - c r t - c o n v e r t - l 1 - 1 - 0 . d l l »⁄ÿ=2    † å     1   $ 1H4ª•Ï€ ëf&»⁄ÿ ∆7¿Ï€9Ïx¿Ï€ P      I              %a p i - m s - w i n - c r t - e n v i r o n m e n t - l 1 - 1 - 0 .  l l •Ï€              1   $ Õ—5ª•Ï€ æó'»⁄ÿ‡.∂†•Ï€â˘5ª•Ï€ P      O              $a p i - m s - w i n - c r t - f i l e s y s t e m - l 1 - 1 - 0 . d l l ü†•Ï€B2   6 ê ~     1   $ 7ª•Ï€ æó'»⁄ÿ+œ∂†•Ï€ü>7ª•Ï€ P      K              a p i - m s - w i n - c r t - h e a p - l 1 - 1 - 0 . d l l €l2   7 ò Ç     1   $ Øy8ª•Ï€ ëf&»⁄ÿ!ø∑†•Ï€i£8ª•Ï€ P      I               a p i - m s - w i n - c r t - l o c a l e - l 1 - 1 - 0 . d l l ó'»⁄ÿw2   " ê ~     1   $ Ë∂9ª•Ï€ æó'»⁄ÿú∏†•Ï ﬁ9ª•Ï€ Ä      q              a p i - m s - w i n - c r t - m a t h - l 1 - 1 - 0 . d l l €~2    ò à     1   $ ™√:ª•Ï€ æó'»⁄ÿ&fπ†•Ï€~Î:ª•Ï€ p      g              #a p i - m s - w i n - c r t - m u l t i b y t e - l 1 - 1 - 0 . d l l £2    ò Ñ     1   $ X˛;ª•Ï€ æó'»⁄ÿÌf∫†•Ï€X˛;ª•Ï€                    !a p i - m s - w i n - c r t - p r i v a t e - l 1 - 1 - 0 . d l l »⁄ÿØ2   3 ò Ñ     1   $ ¡
=ª•Ï€ æó'»⁄ÿﬂ¸∫†•Ï€Ó1=ª•Ï€ P      K              !a p i - m s - w i n - c r t  p r o c e s s - l 1 - 1 - 0 . d l l »⁄ÿ±2   I ò Ñ     1   $ Ô0>ª•Ï€ æó'»⁄ÿÃ¨ª†•Ï€X>ª•Ï€ `      Y              !a p i - m s - w i n - c r t - r u n t i m e - l 1 - 1 - 0 . d l l »⁄ÿ¬2   ∞ ê Ä     1   $ «/?ª•Ï€ æó'»⁄ÿÍ)º†•Ï€V?ª•Ï€ `      _              a p i - m s - w i n - c r t - s t d i o - l 1 - 1 - 0 . d l l 1   B p Z     1   $ íÈª•Ï€ æó'»⁄ÿ[Áû†•Ï€”ª•Ï€ P      I              A P I - M S ~ 1 . D L L       1   
 p Z     1   $ ‘Œª•Ï€ æó'»⁄ÿwòü†•Ï€ˆª•Ï€ P     G              A P I - M S ~ 2 . D L L       *1   – p Z     1   $ à¶ª•Ï€ æó'»⁄ÿc`††•Ï€πÕª•Ï€ P      G              A P I - M S ~ 3 . D L L       01   ( p Z     1   $ ‡∏ª•Ï€ æó'»⁄ÿj°†•Ï€‡∏ª•Ï€ P      G              A P I - M S ~ 4 . D L L       1   7 h R     1   $ IÃª•Ï€ æó'»⁄ÿ9Çó†•Ï€jÛª•Ï€8       7               W P N ~ 1 . J S                                                                                                                                            ` –!âZ≈HÄñÇò@H   #0hw $ , FullS creenDet ectThrea d(): Not(ify>s>(E vent=0,P ID=10692 ,ProcNam e=explorÄer.exe,2 ,iswindowed Sour ce=-1) s uccess \ Ö†£õ úÌı™q˚

º`ÄpÚOƒÅÄ‘≠°dˆóò °EãÖ;`ÙÉ' \\ .\DISPLA<Y1Ö	ˇ ¡Åe  Y  H  V± @   "N  Ä$ÄÄ ` –!ßÏuHÄñÇò@H   #0∞y $ ,x  Rea dRegKey  GetValu e failed@ for v =@ Check Fi stration  and ulS ize = 26 0 with err 5code H0x0 2.~ ` Û;√Å ÄÒ7xt˚1ùõ≥'∞<LåùXı/±¯T¢qÉÅ
Äá Åâ " ÚÉ\Ñ3Ö  ¸ ˇ  ÖÅÅ#ââåÄîãGÖ †ÿ¨™dˆÄc»¸Ö{ÖÅ;ÅÖgÊ∏ÑSÖOıHÉoÖÉ"ˇÄÁÄWÅ≈≈≈≈	Õ≈ƒ¡Åe  Y  H  V± @   "N  Ä$ÄÄ `