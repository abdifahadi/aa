/*! firebase-admin v11.11.1 */
/*!
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface representing base properties of a user-enrolled second factor for a
 * `CreateRequest`.
 */
export interface BaseCreateMultiFactorInfoRequest {
    /**
     * The optional display name for an enrolled second factor.
     */
    displayName?: string;
    /**
     * The type identifier of the second factor. For SMS second factors, this is `phone`.
     */
    factorId: string;
}
/**
 * Interface representing a phone specific user-enrolled second factor for a
 * `CreateRequest`.
 */
export interface CreatePhoneMultiFactorInfoRequest extends BaseCreateMultiFactorInfoRequest {
    /**
     * The phone number associated with a phone second factor.
     */
    phoneNumber: string;
}
/**
 * Type representing the properties of a user-enrolled second factor
 * for a `CreateRequest`.
 */
export type CreateMultiFactorInfoRequest = CreatePhoneMultiFactorInfoRequest;
/**
 * Interface representing common properties of a user-enrolled second factor
 * for an `UpdateRequest`.
 */
export interface BaseUpdateMultiFactorInfoRequest {
    /**
     * The ID of the enrolled second factor. This ID is unique to the user. When not provided,
     * a new one is provisioned by the Auth server.
     */
    uid?: string;
    /**
     * The optional display name for an enrolled second factor.
     */
    displayName?: string;
    /**
     * The optional date the second factor was enrolled, formatted as a UTC string.
     */
    enrollmentTime?: string;
    /**
     * The type identifier of the second factor. For SMS second factors, this is `phone`.
     */
    factorId: string;
}
/**
 * Interface representing a phone specific user-enrolled second factor
 * for an `UpdateRequest`.
 */
export interface UpdatePhoneMultiFactorInfoRequest extends BaseUpdateMultiFactorInfoRequest {
    /**
     * The phone number associated with a phone second factor.
     */
    phoneNumber: string;
}
/**
 * Type representing the properties of a user-enrolled second factor
 * for an `UpdateRequest`.
 */
export type UpdateMultiFactorInfoRequest = UpdatePhoneMultiFactorInfoRequest;
/**
 * The multi-factor related user settings for create operations.
 */
export interface MultiFactorCreateSettings {
    /**
     * The created user's list of enrolled second factors.
     */
    enrolledFactors: CreateMultiFactorInfoRequest[];
}
/**
 * The multi-factor related user settings for update operations.
 */
export interface MultiFactorUpdateSettings {
    /**
     * The updated list of enrolled second factors. The provided list overwrites the user's
     * existing list of second factors.
     * When null is passed, all of the user's existing second factors are removed.
     */
    enrolledFactors: UpdateMultiFactorInfoRequest[] | null;
}
/**
 * Interface representing the properties to update on the provided user.
 */
export interface UpdateRequest {
    /**
     * Whether or not the user is disabled: `true` for disabled;
     * `false` for enabled.
     */
    disabled?: boolean;
    /**
     * The user's display name.
     */
    displayName?: string | null;
    /**
     * The user's primary email.
     */
    email?: string;
    /**
     * Whether or not the user's primary email is verified.
     */
    emailVerified?: boolean;
    /**
     * The user's unhashed password.
     */
    password?: string;
    /**
     * The user's primary phone number.
     */
    phoneNumber?: string | null;
    /**
     * The user's photo URL.
     */
    photoURL?: string | null;
    /**
     * The user's updated multi-factor related properties.
     */
    multiFactor?: MultiFactorUpdateSettings;
    /**
     * Links this user to the specified provider.
     *
     * Linking a provider to an existing user account does not invalidate the
     * refresh token of that account. In other words, the existing account
     * would continue to be able to access resources, despite not having used
     * the newly linked provider to log in. If you wish to force the user to
     * authenticate with this new provider, you need to (a) revoke their
     * refresh token (see
     * https://firebase.google.com/docs/auth/admin/manage-sessions#revoke_refresh_tokens),
     * and (b) ensure no other authentication methods are present on this
     * account.
     */
    providerToLink?: UserProvider;
    /**
     * Unlinks this user from the specified providers.
     */
    providersToUnlink?: string[];
}
/**
 * Represents a user identity provider that can be associated with a Firebase user.
 */
export interface UserProvider {
    /**
     * The user identifier for the linked provider.
     */
    uid?: string;
    /**
     * The display name for the linked provider.
     */
    displayName?: string;
    /**
     * The email for the linked provider.
     */
    email?: string;
    /**
     * The phone number for the linked provider.
     */
    phoneNumber?: string;
    /**
     * The photo URL for the linked provider.
     */
    photoURL?: string;
    /**
     * The linked provider ID (for example, "google.com" for the Google provider).
     */
    providerId?: string;
}
/**
 * Interface representing the properties to set on a new user record to be
 * created.
 */
export interface CreateRequest extends UpdateRequest {
    /**
     * The user's `uid`.
     */
    uid?: string;
    /**
     * The user's multi-factor related properties.
     */
    multiFactor?: MultiFactorCreateSettings;
}
/**
 * The response interface for listing provider configs. This is only available
 * when listing all identity providers' configurations via
 * {@link BaseAuth.listProviderConfigs}.
 */
export interface ListProviderConfigResults {
    /**
     * The list of providers for the specified type in the current page.
     */
    providerConfigs: AuthProviderConfig[];
    /**
     * The next page token, if available.
     */
    pageToken?: string;
}
/**
 * The filter interface used for listing provider configurations. This is used
 * when specifying how to list configured identity providers via
 * {@link BaseAuth.listProviderConfigs}.
 */
export interface AuthProviderConfigFilter {
    /**
     * The Auth provider configuration filter. This can be either `saml` or `oidc`.
     * The former is used to look up SAML providers only, while the latter is used
     * for OIDC providers.
     */
    type: 'saml' | 'oidc';
    /**
     * The maximum number of results to return per page. The default and maximum is
     * 100.
     */
    maxResults?: number;
    /**
     * The next page token. When not specified, the lookup starts from the beginning
     * of the list.
     */
    pageToken?: string;
}
/**
 * The request interface for updating a SAML Auth provider. This is used
 * when updating a SAML provider's configuration via
 * {@link BaseAuth.updateProviderConfig}.
 */
export interface SAMLUpdateAuthProviderRequest {
    /**
     * The SAML provider's updated display name. If not provided, the existing
     * configuration's value is not modified.
     */
    displayName?: string;
    /**
     * Whether the SAML provider is enabled or not. If not provided, the existing
     * configuration's setting is not modified.
     */
    enabled?: boolean;
    /**
     * The SAML provider's updated IdP entity ID. If not provided, the existing
     * configuration's value is not modified.
     */
    idpEntityId?: string;
    /**
     * The SAML provider's updated SSO URL. If not provided, the existing
     * configuration's value is not modified.
     */
    ssoURL?: string;
    /**
     * The SAML provider's updated list of X.509 certificated. If not provided, the
     * existing configuration list is not modified.
     */
    x509Certificates?: string[];
    /**
     * The SAML provider's updated RP entity ID. If not provided, the existing
     * configuration's value is not modified.
     */
    rpEntityId?: string;
    /**
     * The SAML provider's callback URL. If not provided, the existing
     * configuration's value is not modified.
     */
    callbackURL?: string;
}
/**
 * The request interface for updating an OIDC Auth provider. This is used
 * when updating an OIDC provider's configuration via
 * {@link BaseAuth.updateProviderConfig}.
 */
export interface OIDCUpdateAuthProviderRequest {
    /**
     * The OIDC provider's updated display name. If not provided, the existing
     * configuration's value is not modified.
     */
    displayName?: string;
    /**
     * Whether the OIDC provider is enabled or not. If not provided, the existing
     * configuration's setting is not modified.
     */
    enabled?: boolean;
    /**
     * The OIDC provider's updated client ID. If not provided, the existing
     * configuration's value is not modified.
     */
    clientId?: string;
    /**
     * The OIDC provider's updated issuer. If not provided, the existing
     * configuration's value is not modified.
     */
    issuer?: string;
    /**
     * The OIDC provider's client secret to enable OIDC code flow.
     * If not provided, the existing configuration's value is not modified.
     */
    clientSecret?: string;
    /**
     * The OIDC provider's response object for OAuth authorization flow.
     */
    responseType?: OAuthResponseType;
}
export type UpdateAuthProviderRequest = SAMLUpdateAuthProviderRequest | OIDCUpdateAuthProviderRequest;
/** A maximum of 10 test phone number / code pairs can be configured. */
export declare const MAXIMUM_TEST_PHONE_NUMBERS = 10;
/** The server side SAML configuration request interface. */
export interface SAMLConfigServerRequest {
    idpConfig?: {
        idpEntityId?: string;
        ssoUrl?: string;
        idpCertificates?: Array<{
            x509Certificate: string;
        }>;
        signRequest?: boolean;
    };
    spConfig?: {
        spEntityId?: string;
        callbackUri?: string;
    };
    displayName?: string;
    enabled?: boolean;
    [key: string]: any;
}
/** The server side SAML configuration response interface. */
export interface SAMLConfigServerResponse {
    name?: string;
    idpConfig?: {
        idpEntityId?: string;
        ssoUrl?: string;
        idpCertificates?: Array<{
            x509Certificate: string;
        }>;
        signRequest?: boolean;
    };
    spConfig?: {
        spEntityId?: string;
        callbackUri?: string;
    };
    displayName?: string;
    enabled?: boolean;
}
/** The server side OIDC configuration request interface. */
export interface OIDCConfigServerRequest {
    clientId?: string;
    issuer?: string;
    displayName?: string;
    enabled?: boolean;
    clientSecret?: string;
    responseType?: OAuthResponseType;
    [key: string]: any;
}
/** The server side OIDC configuration response interface. */
export interface OIDCConfigServerResponse {
    name?: string;
    clientId?: string;
    issuer?: string;
    displayName?: string;
    enabled?: boolean;
    clientSecret?: string;
    responseType?: OAuthResponseType;
}
/** The server side email configuration request interface. */
export interface EmailSignInConfigServerRequest {
    allowPasswordSignup?: boolean;
    enableEmailLinkSignin?: boolean;
}
/** Identifies the server side second factor type. */
type AuthFactorServerType = 'PHONE_SMS';
/** Server side multi-factor configuration. */
export interface MultiFactorAuthServerConfig {
    state?: MultiFactorConfigState;
    enabledProviders?: AuthFactorServerType[];
    providerConfigs?: MultiFactorProviderConfig[];
}
/**
 * Identifies a second factor type.
 */
export type AuthFactorType = 'phone';
/**
 * Identifies a multi-factor configuration state.
 */
export type MultiFactorConfigState = 'ENABLED' | 'DISABLED';
/**
 * Interface representing aimport { GaxiosOptions, GaxiosPromise, GaxiosResponse } from 'gaxios';
import { BodyResponseCallback } from '../transporters';
import { Credentials } from './credentials';
import { AuthClient } from './authclient';
import { GetAccessTokenResponse, Headers, RefreshOptions } from './oauth2client';
/**
 * The maximum number of access boundary rules a Credential Access Boundary
 * can contain.
 */
export declare const MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
/**
 * Offset to take into account network delays and server clock skews.
 */
export declare const EXPIRATION_TIME_OFFSET: number;
/**
 * Internal interface for tracking the access token expiration time.
 */
interface CredentialsWithResponse extends Credentials {
    res?: GaxiosResponse | null;
}
/**
 * Internal interface for tracking and returning the Downscoped access token
 * expiration time in epoch time (seconds).
 */
interface DownscopedAccessTokenResponse extends GetAccessTokenResponse {
    expirationTime?: number | null;
}
/**
 * Defines an upper bound of permissions available for a GCP credential.
 */
export interface CredentialAccessBoundary {
    accessBoundary: {
        accessBoundaryRules: AccessBoundaryRule[];
    };
}
/** Defines an upper bound of permissions on a particular resource. */
interface AccessBoundaryRule {
    availablePermissions: string[];
    availableResource: string;
    availabilityCondition?: AvailabilityCondition;
}
/**
 * An optional condition that can be used as part of a
 * CredentialAccessBoundary to further restrict permissions.
 */
interface AvailabilityCondition {
    expression: string;
    title?: string;
    description?: string;
}
/**
 * Defines a set of Google credentials that are downscoped from an existing set
 * of Google OAuth2 credentials. This is useful to restrict the Identity and
 * Access Management (IAM) permissions that a short-lived credential can use.
 * The common pattern of usage is to have a token broker with elevated access
 * generate these downscoped credentials from higher access source credentials
 * and pass the downscoped short-lived access tokens to a token consumer via
 * some secure authenticated channel for limited access to Google Cloud Storage
 * resources.
 */
export declare class DownscopedClient extends AuthClient {
    private readonly authClient;
    private readonly credentialAccessBoundary;
    private cachedDownscopedAccessToken;
    private readonly stsCredential;
    readonly eagerRefreshThresholdMillis: number;
    readonly forceRefreshOnFailure: boolean;
    /**
     * Instantiates a downscoped client object using the provided source
     * AuthClient and credential access boundary rules.
     * To downscope permissions of a source AuthClient, a Credential Access
     * Boundary that specifies which resources the new credential can access, as
     * well as an upper bound on the permissions that are available on each
     * resource, has to be defined. A downscoped client can then be instantiated
     * using the source AuthClient and the Credential Access Boundary.
     * @param authClient The source AuthClient to be downscoped based on the
     *   provided Credential Access Boundary rules.
     * @param credentialAccessBoundary The Credential Access Boundary which
     *   contains a list of access boundary rules. Each rule contains information
     *   on the resource that the rule applies to, the upper bound of the
     *   permissions that are available on that resource and an optional
     *   condition to further restrict permissions.
     * @param additionalOptions Optional additional behavior customization
     *   options. These currently customize expiration threshold time and
     *   whether to retry on 401/403 API request errors.
     * @param quotaProjectId Optional quota project id for setting up in the
     *   x-goog-user-project header.
     */
    constructor(authClient: AuthClient, credentialAccessBoundary: CredentialAccessBoundary, additionalOptions?: RefreshOptions, quotaProjectId?: string);
    /**
     * Provides a mechanism to inject Downscoped access tokens directly.
     * The expiry_date field is required to facilitate determination of the token
     * expiration which would make it easier for the token consumer to handle.
     * @param credentials The Credentials object to set on the current client.
     */
    setCredentials(credentials: Credentials): void;
    getAccessToken(): Promise<DownscopedAccessTokenResponse>;
    /**
     * The main authentication interface. It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * The result has the form:
     * { Authorization: 'Bearer <access_token_value>' }
     */
    getRequestHeaders(): Promise<Headers>;
    /**
     * Provides a request implementation with OAuth 2.0 flow. In cases of
     * HTTP 401 and 403 responses, it automatically asks for a new access token
     * and replays the unsuccessful request.
     * @param opts Request options.
     * @param callback callback.
     * @return A promise that resolves with the HTTP response when no callback
     *   is provided.
     */
    request<T>(opts: GaxiosOptions): GaxiosPromise<T>;
    request<T>(opts: GaxiosOptions, callback: BodyResponseCallback<T>): void;
    /**
     * Authenticates the provided HTTP request, processes it and resolves with the
     * returned response.
     * @param opts The HTTP request options.
     * @param retry Whether the current attempt is a retry after a failed attempt.
     * @return A promise that resolves with the successful response.
     */
    protected requestAsync<T>(opts: GaxiosOptions, retry?: boolean): Promise<GaxiosResponse<T>>;
    /**
     * Forces token refresh, even if unexpired tokens are currently cached.
     * GCP access tokens are retrieved from authclient object/source credential.
     * Then GCP access tokens are exchanged for downscoped access tokens via the
     * token exchange endpoint.
     * @return A promise that resolves with the fresh downscoped access token.
     */
    protected refreshAccessTokenAsync(): Promise<CredentialsWithResponse>;
    /**
     * Returns whether the provided credentials are expired or not.
     * If there is no expiry time, assumes the token is not expired or expiring.
     * @param downscopedAccessToken The credentials to check for expiration.
     * @return Whether the credentials are expired or not.
     */
    private isExpired;
}
export {};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅX  L  H  I± @   "N  Ä$ÄÄ ` –A†j‘6 PÄñò@H  G 0¿W $
 , IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=DRWU I.exe, A ppWindow Width=58 'aHeight=2Moniàtor&192 '≥%10&òsò!q_DCS^Si zeDiv
bIÇs
ed=0)Äg†ò¬˚õàyÅà  ÃÅ  AåÿOƒÅ `bıÉ  ùÑ#Éd¿Òt˚ ÇõÅKÉ"áÄ ´8á@ûäCáÎ¿Øåéù¡C¡A¡'y¨¬%¡Å$    H  ± @   "N  Ä$ÄÄ ` –Aök‘6 PÄñò@H  G 0Z $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅX  L  H  I± @   "N  Ä$ÄÄ ` –A±∫÷6 PÄñò@H  G 0P\ $
 , IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=DRWU I.exe, A ppWindow Width=58 'aHeight=2Moniàtor&192 '≥%10&òsò!q_DCS^Si zeDiv
bIÇs
ed=0)Äg†ò¬˚õàyÅà  LÅ  AåÿOƒÅ `bıÉ  ùÑ#Éd¿Òt˚ ÇõÅKÉ"áÄ ´8á@ûäCáÎp∑åéù¡C¡A¡'êz¨¬%¡Å$    H  ± @   "N  Ä$ÄÄ ` –A™ª÷6 PÄñò@H  G 0ò^ $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅX  L  H  I± @   "N  Ä$ÄÄ ` –Aöë€6 PÄñò@H  G 0‡` $
 , IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=DRWU I.exe, A ppWindow Width=58 'aHeight=2Moniàtor&192 '≥%10&òsò!q_DCS^Si zeDiv
bIÇs
ed=0)Äg†ò¬˚õàyÅà  ÃÅ  AåÿOƒÅ `bıÉ  ùÑ#Éd¿Òt˚ ÇõÅKÉ"áÄ ´8á@ûäCáÎÀåéù¡C¡A¡'@{¨¬%¡Å$    H  ± @   "N  Ä$ÄÄ ` –AÄí€6 PÄñò@H  G 0(c $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅV  J  H  G± @   "N  Ä$ÄÄ ` –APhﬁ6 PÄñò@H  G 0pe $
 , IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=DRWU I.exe, A ppWindow Width=58 'aHeight=2Moniàtor&192 '≥%10&òsò!q_DCS^Si zeDiv
bIÇs
ed=0)Äg†ò¬˚õàyÅà  ÃÅ  AåÿOƒÅ `bıÉ  ùÑ#Éd¿Òt˚ ÇõÅKÉ"áÄ ´8á@ûäCáÎêºåŒù¡C¡A¬'z¨¬%¡Å$    H  ± @   "N  Ä$ÄÄ ` –AFiﬁ6 PÄñò@H  G 0∏g $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅV  J  H  G± @   "N  Ä$ÄÄ ` –Aiô„6 PÄñò@H  ' 0j $ , IsFul lScreen( ): (Tole ranceMod e=1,  In Pixels=0 , ProcNa me=DRWUI .exe, Ap pWindowWÄidth=58 'aHeight=2Monitƒor&192 'Ÿ%10&òsòq_DCS^SizeDiv
bIsA
ed=0)Ägò–¬˚õàyÅà à ‘Å  å ÿOƒÅ `ı1É  ùÑ#ÉdÒ‡t˚ ÇõÅÉ"%áÄ ´8á@ûäCáÎP≤åù«¡C¡A¡'Py¨√%¿Å$    H  ± @   "N  Ä$ÄÄ ` –Aåö„6 PÄñò@H  G 0Hl $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅX  L  H  I± @   "N  Ä$ÄÄ ` –AKêÊ6 PÄñò@H  G 0ên $
 , IsFu llScreen (): (Tol eranceMo@de=1,  I nPixels= 0, ProcN ame=DRWU I.exe, A ppWindow Width=58 'aHeight=2Moniàtor&192 '≥%10&òsò!q_DCS^Si zeDiv
bIÇs
ed=0)Äg†ò¬˚õàyÅà  ÃÅ  AåÿOƒÅ `bıÉ  ùÑ#Éd¿Òt˚ ÇõÅKÉ"áÄ ´8á@ûäCáÎ∞¡åéù¡C¡A¡'`y¨¬%¡Å$    H  ± @   "N  Ä$ÄÄ ` –AQëÊ6 PÄñò@H  G 0ÿp $
 , Full ScreenDe tectThre ad(): NoPtify>s>( Event=1, PID=1363 2,ProcNa me=DRWUI .exe,/=0 ,iswindowed Sour ce=-1) s@uccess ~ Ñè	†£õ úÌı™q˚6	º` 
pÚOƒÅÄ‘≠°d.ˆò °E3ãÖ;`ÙÉ' \ \.\DISPLxAY1Ö	ˇ ¡ÅX  L  H  I± @   "N  Ä$ÄÄ ` –A RÈ6 PÄñò@H  G 0 s $
 , IsFu llâPNG

   IHDR   Ï   à   ‰∂X   sRGB ÆŒÈ  €IDATxÌõ€n›∆ÜÁ@roIâÎ4)
π0ä ¥/“õæMﬂ†œ”WI	`∫(ÍIW÷>êúCˇ5w’⁄YEdc¡˛â8§»≈·“7¯ºÜ√±wwlµVø\Úﬁ◊Âò{ Å◊C@„\w˚—7naÂè»JaoÉ‚œ$pˇŒ¡√÷˙Ìbyˆ¢.7Á˚œã-í 	‹A ‡¸R$°ÂO≈ïã7∑E“Ù©ãœû=Îqë’ı&!ì¿Î#P≈9qè7Ol¬^W◊Âb8??è”Ùm?é„pª$Ó‰	ê¿Ω◊ƒ9qOD„ióÕ
+¬6Y∑€≥.Á]yYW˜ö#8J@ú˜ƒ¡[“∂˚¬ÕÍäRYc,´ÆÛ'G[ÁE Å{% Œâ{ã¥‚$–Fø‚ÍRa˝ì'.úù=ãßßõŒ˚<Ñ‡÷•Ñ≥{ÕÜçë 	% Œâ{‚†∏(Näõ∏I§uáY‚ap˛‚¢èﬁª.Ñ›*•pB¶∞GÒÚ"	‹7Å|˜J•L”:ècü·Ê·Kç€ Ìz˝œêRäªù«Ã0îíOºgÖΩÔÓ`{$på@≠·¨óBÊúß˘‰dL]∑GÖ˝∏yzˇªÔ√~ﬂ«ú{H\VRñSeÖ=ó◊H‡æ	às‚û8(.äì‚&û”ÜƒMXåë}˜}]CÈg∂/!≠£Ûß˜ù€#∏õÄ8'Ó5·¢8)nä£rWÀ˚´s1L”&ˆæt’˘¡g∑*ÕÙªÁ Å˚%P<&ú‡ûãuËKÈ¶ºè√`©∞áYb¬cƒ{làò©Í0ñÜª∏ë	ê¿# Œâ{‚†∏(NäõKmH‹uÁg±–¬CZôü*±Ü
i´,M‰F$Üàs‚û8(.äì‚¶8*),•÷Ω|¸~Ô}Ú≥ÖP}t∏ÒÂ…«ê 	8'ÓâÉ‚¢8)n^√π„Õˆ ^Q5â≠>Ï\˘q»Lö$@oÄ ú˜ƒ¡kõõGóP~ù±…9¨¥ê£≈Ï%å{ Å◊H@ú˜‰‚¢8)n.èlÔ∞ÀÀ>Cm_Àı∑üÂ<˜$@Øó@sÓ5_Ò®W
˚ä8û"0@Ä¬Ë¶@ZVKäq$`Ä Ö5–	LÅ¥(¨ñ„H¿ 
k†ò	h	PX-)∆ëÄ÷@'0–†∞ZRå#(¨ÅN`
$†%@aµ§GPXù¿H@KÄ¬jI1é†∞:Å)êÄñ Ö’íb	 @atS -
´%≈80@Ä¬Ë¶@ZVKäq$`Ä Ö5–	LÅ¥(¨ñ„H¿ 
k†ò	h	PX-)∆ëÄ÷@'0–†∞ZRå#(¨ÅN`
$†%@aµ§GPXù¿H@KÄ¬jI1é†∞:Å)êÄñ Ö’íb	 @atS -
´%≈80@Ä¬Ë¶@ZVKäq$`Ä Ö5–	LÅ¥(¨ñ„H¿ 
k†ò	h	PX-)∆ëÄ÷@'0–†∞ZRå#(¨ÅN`
$†%@aµ§GPXù¿H@KÄ¬jI